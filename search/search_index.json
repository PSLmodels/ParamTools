{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ParamTools Define, update, and validate your model's parameters. How to use ParamTools Subclass paramtools.Parameters and define your model's parameters : import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" , \"number_dims\" : 0 }, \"cpi_inflated\" : { \"type\" : \"bool\" , \"number_dims\" : 0 } } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : True , \"cpi_inflated\" : True , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7690.0 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15380.0 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } params = TaxParams ( initial_state = { \"year\" : [ 2024 , 2025 , 2026 ]}, array_first = True ) Check out the state: params . view_state () # {'year': [2024, 2025, 2026]} Parameters are available via instance attributes: params . standard_deduction # array([[13673.68, 27347.36], # [13967.66, 27935.33], # [ 7690. , 15380. ]]) Take a look at the standard deduction parameter's labels: params . from_array ( \"standard_deduction\" ) # [{'year': 2024, 'marital_status': 'single', 'value': 13673.68}, # {'year': 2024, 'marital_status': 'joint', 'value': 27347.36}, # {'year': 2025, 'marital_status': 'single', 'value': 13967.66}, # {'year': 2025, 'marital_status': 'joint', 'value': 27935.33}, # {'year': 2026, 'marital_status': 'single', 'value': 7690.0}, # {'year': 2026, 'marital_status': 'joint', 'value': 15380.0}] Query the parameters: params . specification ( year = 2026 , marital_status = \"single\" , use_state = False ) # OrderedDict([('standard_deduction', # [{'value': 0.0, 'year': 2026, 'marital_status': 'single'}])]) Adjust the default values: adjustment = { \"standard_deduction\" : [ { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 10000.0 } ], } params . adjust ( adjustment ) params . standard_deduction # array([[13673.68, 27347.36], # [13967.66, 27935.33], # [10000. , 15380. ]]) Set all values of the standard deduction parameter to 0: adjustment = { \"standard_deduction\" : 0 , } params . adjust ( adjustment ) params . standard_deduction # array([[0., 0.], # [0., 0.], # [0., 0.]]) Errors on invalid input: adjustment [ \"standard_deduction\" ] = \"higher\" params . adjust ( adjustment ) # --------------------------------------------------------------------------- # ValidationError Traceback (most recent call last) # <ipython-input-7-d9ad03cf54d8> in <module> # 1 adjustment[\"standard_deduction\"] = \"higher\" # ----> 2 params.adjust(adjustment) # ~/Documents/ParamTools/paramtools/parameters.py in adjust(self, params_or_path, raise_errors) # 134 # 135 if raise_errors and self._errors: # --> 136 raise self.validation_error # 137 # 138 # Update attrs. # ValidationError: {'standard_deduction': ['Not a valid number: higher.']} Errors on input that's out of range: adjustment [ \"standard_deduction\" ] = [ { \"marital_status\" : \"single\" , \"year\" : 2025 , \"value\" : - 1 } ] params . adjust ( adjustment ) # output: # --------------------------------------------------------------------------- # ValidationError Traceback (most recent call last) # <ipython-input-14-208948dfbd1d> in <module> # 1 adjustment[\"standard_deduction\"] = [{\"marital_status\": \"single\", \"year\": 2025, \"value\": -1}] # ----> 2 params.adjust(adjustment) # ~/Documents/ParamTools/paramtools/parameters.py in adjust(self, params_or_path, raise_errors, extend_adj) # 183 # 184 if raise_errors and self._errors: # --> 185 raise self.validation_error # 186 # 187 if self.label_to_extend is not None and extend_adj: # ValidationError: { # \"standard_deduction\": [ # \"standard_deduction[marital_status=single, year=2025] -1.0 < min 0 \" # ] # } How to install ParamTools Install with conda: conda install -c conda-forge paramtools Install from source: git clone https : // github . com / PSLmodels / ParamTools cd ParamTools conda env create conda activate paramtools - dev pip install - e . # optionally run tests : py . test - v Documentation Full documentation available at paramtools.dev . Contributing Contributions are welcome! Checkout CONTRIBUTING.md to get started. Credits ParamTools is built on top of the excellent marshmallow JSON schema and validation framework. I encourage everyone to check out their repo and documentation. ParamTools was modeled off of Tax-Calculator's parameter processing and validation engine due to its maturity and sophisticated capabilities.","title":"Home"},{"location":"#paramtools","text":"Define, update, and validate your model's parameters.","title":"ParamTools"},{"location":"#how-to-use-paramtools","text":"Subclass paramtools.Parameters and define your model's parameters : import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" , \"number_dims\" : 0 }, \"cpi_inflated\" : { \"type\" : \"bool\" , \"number_dims\" : 0 } } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : True , \"cpi_inflated\" : True , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7690.0 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15380.0 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } params = TaxParams ( initial_state = { \"year\" : [ 2024 , 2025 , 2026 ]}, array_first = True ) Check out the state: params . view_state () # {'year': [2024, 2025, 2026]} Parameters are available via instance attributes: params . standard_deduction # array([[13673.68, 27347.36], # [13967.66, 27935.33], # [ 7690. , 15380. ]]) Take a look at the standard deduction parameter's labels: params . from_array ( \"standard_deduction\" ) # [{'year': 2024, 'marital_status': 'single', 'value': 13673.68}, # {'year': 2024, 'marital_status': 'joint', 'value': 27347.36}, # {'year': 2025, 'marital_status': 'single', 'value': 13967.66}, # {'year': 2025, 'marital_status': 'joint', 'value': 27935.33}, # {'year': 2026, 'marital_status': 'single', 'value': 7690.0}, # {'year': 2026, 'marital_status': 'joint', 'value': 15380.0}] Query the parameters: params . specification ( year = 2026 , marital_status = \"single\" , use_state = False ) # OrderedDict([('standard_deduction', # [{'value': 0.0, 'year': 2026, 'marital_status': 'single'}])]) Adjust the default values: adjustment = { \"standard_deduction\" : [ { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 10000.0 } ], } params . adjust ( adjustment ) params . standard_deduction # array([[13673.68, 27347.36], # [13967.66, 27935.33], # [10000. , 15380. ]]) Set all values of the standard deduction parameter to 0: adjustment = { \"standard_deduction\" : 0 , } params . adjust ( adjustment ) params . standard_deduction # array([[0., 0.], # [0., 0.], # [0., 0.]]) Errors on invalid input: adjustment [ \"standard_deduction\" ] = \"higher\" params . adjust ( adjustment ) # --------------------------------------------------------------------------- # ValidationError Traceback (most recent call last) # <ipython-input-7-d9ad03cf54d8> in <module> # 1 adjustment[\"standard_deduction\"] = \"higher\" # ----> 2 params.adjust(adjustment) # ~/Documents/ParamTools/paramtools/parameters.py in adjust(self, params_or_path, raise_errors) # 134 # 135 if raise_errors and self._errors: # --> 136 raise self.validation_error # 137 # 138 # Update attrs. # ValidationError: {'standard_deduction': ['Not a valid number: higher.']} Errors on input that's out of range: adjustment [ \"standard_deduction\" ] = [ { \"marital_status\" : \"single\" , \"year\" : 2025 , \"value\" : - 1 } ] params . adjust ( adjustment ) # output: # --------------------------------------------------------------------------- # ValidationError Traceback (most recent call last) # <ipython-input-14-208948dfbd1d> in <module> # 1 adjustment[\"standard_deduction\"] = [{\"marital_status\": \"single\", \"year\": 2025, \"value\": -1}] # ----> 2 params.adjust(adjustment) # ~/Documents/ParamTools/paramtools/parameters.py in adjust(self, params_or_path, raise_errors, extend_adj) # 183 # 184 if raise_errors and self._errors: # --> 185 raise self.validation_error # 186 # 187 if self.label_to_extend is not None and extend_adj: # ValidationError: { # \"standard_deduction\": [ # \"standard_deduction[marital_status=single, year=2025] -1.0 < min 0 \" # ] # }","title":"How to use ParamTools"},{"location":"#how-to-install-paramtools","text":"Install with conda: conda install -c conda-forge paramtools Install from source: git clone https : // github . com / PSLmodels / ParamTools cd ParamTools conda env create conda activate paramtools - dev pip install - e . # optionally run tests : py . test - v","title":"How to install ParamTools"},{"location":"#documentation","text":"Full documentation available at paramtools.dev .","title":"Documentation"},{"location":"#contributing","text":"Contributions are welcome! Checkout CONTRIBUTING.md to get started.","title":"Contributing"},{"location":"#credits","text":"ParamTools is built on top of the excellent marshmallow JSON schema and validation framework. I encourage everyone to check out their repo and documentation. ParamTools was modeled off of Tax-Calculator's parameter processing and validation engine due to its maturity and sophisticated capabilities.","title":"Credits"},{"location":"parameters/","text":"Parameters Define your default parameters and let ParamTools handle the rest. The ParamTools JSON file is split into two components: a component that defines the structure of your default inputs and a component that defines the variables that are used in your model. The first component is a top level member named schema . The second component consists of key-value pairs where the key is the parameter's name and the value is its data. { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" , \"separate\" , \"headhousehold\" , \"widow\" ]}} }, }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" }, \"cpi_inflated\" : { \"type\" : \"bool\" } }, \"operators\" : { \"array_first\" : true , \"label_to_extend\" : \"year\" , \"uses_extend_func\" : true } }, \"personal_exemption\" : { \"title\" : \"Personal Exemption\" , \"description\" : \"A simple version of the personal exemption.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"value\" : 0 , \"validators\" : { \"range\" : { \"min\" : 0 , } } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2024 , \"marital_status\" : \"separate\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"headhousehold\" , \"value\" : 20510.52 }, { \"year\" : 2024 , \"marital_status\" : \"widow\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2025 , \"marital_status\" : \"separate\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"headhousehold\" , \"value\" : 20951.49 }, { \"year\" : 2025 , \"marital_status\" : \"widow\" , \"value\" : 27935.33 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"level\" : \"warn\" , } } }, } Parameters Schema { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} } }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" }, \"cpi_inflated\" : { \"type\" : \"bool\" } } }, \"operators\" : { \"array_first\" : true , \"label_to_extend\" : true , \"uses_extend_func\" : true } } labels : Labels are used for defining, accessing, and updating a parameter's values. additional_members : Additional Members are parameter level members that are specific to your model. For example, \"title\" is a parameter level member that is required by ParamTools, but \"cpi_inflated\" is not. Therefore, \"cpi_inflated\" needs to be defined in additional_members . operators : Operators affect how the data is read into and handled by the Parameters class: array_first : If value is true , parameters' values will be accessed as arrays by default. label_to_extend : The name of the label along which the missing values of the parameters will be extended. For more information, check out the extend docs . uses_extend_func : If value is true , special logic is applied to the values of the parameters as they are extended. For more information, check out the indexing docs . Default Parameters { \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"number_dims\" : 0 , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2024 , \"marital_status\" : \"separate\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"headhousehold\" , \"value\" : 20510.52 }, { \"year\" : 2024 , \"marital_status\" : \"widow\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2025 , \"marital_status\" : \"separate\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"headhousehold\" , \"value\" : 20951.49 }, { \"year\" : 2025 , \"marital_status\" : \"widow\" , \"value\" : 27935.33 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } } } Members: title : A human readable name for the parameter. description : Describe the parameter. notes : ( optional ) Additional advice or information. type : Data type of the parameter. Allowed types are int , float , bool , str and date (YYYY-MM-DD). number_dims : ( optional, default is 0 ) Number of dimensions for the value, as defined by np.ndim . value : Value of the parameter and optionally, the corresponding labels. It can be written in two ways: if labels are used: {\"value\": [{\"value\": \"my value\", **labels}]} if labels are not used: {\"value\": \"my value\"} validators : Key-value pairs of the validator objects ( the ranges are inclusive ): level : All validators take a level argument which is either \"error\" or \"warn\". By default it is set to \"error\". when : is is set to equal_to by default but can also be greater_than or less_than . e.g: \"is\": {\"greater_than\": 0} If the sub-validators refer to the value of another parameter, then the other parameter must have number_dims equal to 0, i.e. be a scalar value and not an array value. { \"validators\" : { \"range\" : { \"min\" : \"min value\" , \"max\" : \"max value\" , \"level\" : \"warn\" }, \"choice\" : { \"choices\" : [ \"list\" , \"of\" , \"allowed\" , \"values\" ]}, \"date_range\" : { \"min\" : \"2018-01-01\" , \"max\" : \"2018-06-01\" }, \"when\" : { \"param\" : \"other parameter\" , \"is\" : \"equal_value\" , \"then\" : { \"range\" : { \"min\" : \"min value if other parameter is 'equal_value'\" } }, \"otherwise\" : { \"range\" : { \"min\" : \"min value if other parameter is not 'equal_value'\" } } } } }","title":"Parameters"},{"location":"parameters/#parameters","text":"Define your default parameters and let ParamTools handle the rest. The ParamTools JSON file is split into two components: a component that defines the structure of your default inputs and a component that defines the variables that are used in your model. The first component is a top level member named schema . The second component consists of key-value pairs where the key is the parameter's name and the value is its data. { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" , \"separate\" , \"headhousehold\" , \"widow\" ]}} }, }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" }, \"cpi_inflated\" : { \"type\" : \"bool\" } }, \"operators\" : { \"array_first\" : true , \"label_to_extend\" : \"year\" , \"uses_extend_func\" : true } }, \"personal_exemption\" : { \"title\" : \"Personal Exemption\" , \"description\" : \"A simple version of the personal exemption.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"value\" : 0 , \"validators\" : { \"range\" : { \"min\" : 0 , } } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2024 , \"marital_status\" : \"separate\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"headhousehold\" , \"value\" : 20510.52 }, { \"year\" : 2024 , \"marital_status\" : \"widow\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2025 , \"marital_status\" : \"separate\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"headhousehold\" , \"value\" : 20951.49 }, { \"year\" : 2025 , \"marital_status\" : \"widow\" , \"value\" : 27935.33 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"level\" : \"warn\" , } } }, }","title":"Parameters"},{"location":"parameters/#parameters-schema","text":"{ \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} } }, \"additional_members\" : { \"cpi_inflatable\" : { \"type\" : \"bool\" }, \"cpi_inflated\" : { \"type\" : \"bool\" } } }, \"operators\" : { \"array_first\" : true , \"label_to_extend\" : true , \"uses_extend_func\" : true } } labels : Labels are used for defining, accessing, and updating a parameter's values. additional_members : Additional Members are parameter level members that are specific to your model. For example, \"title\" is a parameter level member that is required by ParamTools, but \"cpi_inflated\" is not. Therefore, \"cpi_inflated\" needs to be defined in additional_members . operators : Operators affect how the data is read into and handled by the Parameters class: array_first : If value is true , parameters' values will be accessed as arrays by default. label_to_extend : The name of the label along which the missing values of the parameters will be extended. For more information, check out the extend docs . uses_extend_func : If value is true , special logic is applied to the values of the parameters as they are extended. For more information, check out the indexing docs .","title":"Parameters Schema"},{"location":"parameters/#default-parameters","text":"{ \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"cpi_inflatable\" : true , \"cpi_inflated\" : true , \"type\" : \"float\" , \"number_dims\" : 0 , \"value\" : [ { \"year\" : 2024 , \"marital_status\" : \"single\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"joint\" , \"value\" : 27347.36 }, { \"year\" : 2024 , \"marital_status\" : \"separate\" , \"value\" : 13673.68 }, { \"year\" : 2024 , \"marital_status\" : \"headhousehold\" , \"value\" : 20510.52 }, { \"year\" : 2024 , \"marital_status\" : \"widow\" , \"value\" : 27347.36 }, { \"year\" : 2025 , \"marital_status\" : \"single\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"joint\" , \"value\" : 27935.33 }, { \"year\" : 2025 , \"marital_status\" : \"separate\" , \"value\" : 13967.66 }, { \"year\" : 2025 , \"marital_status\" : \"headhousehold\" , \"value\" : 20951.49 }, { \"year\" : 2025 , \"marital_status\" : \"widow\" , \"value\" : 27935.33 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } } }","title":"Default Parameters"},{"location":"parameters/#members","text":"title : A human readable name for the parameter. description : Describe the parameter. notes : ( optional ) Additional advice or information. type : Data type of the parameter. Allowed types are int , float , bool , str and date (YYYY-MM-DD). number_dims : ( optional, default is 0 ) Number of dimensions for the value, as defined by np.ndim . value : Value of the parameter and optionally, the corresponding labels. It can be written in two ways: if labels are used: {\"value\": [{\"value\": \"my value\", **labels}]} if labels are not used: {\"value\": \"my value\"} validators : Key-value pairs of the validator objects ( the ranges are inclusive ): level : All validators take a level argument which is either \"error\" or \"warn\". By default it is set to \"error\". when : is is set to equal_to by default but can also be greater_than or less_than . e.g: \"is\": {\"greater_than\": 0} If the sub-validators refer to the value of another parameter, then the other parameter must have number_dims equal to 0, i.e. be a scalar value and not an array value. { \"validators\" : { \"range\" : { \"min\" : \"min value\" , \"max\" : \"max value\" , \"level\" : \"warn\" }, \"choice\" : { \"choices\" : [ \"list\" , \"of\" , \"allowed\" , \"values\" ]}, \"date_range\" : { \"min\" : \"2018-01-01\" , \"max\" : \"2018-06-01\" }, \"when\" : { \"param\" : \"other parameter\" , \"is\" : \"equal_value\" , \"then\" : { \"range\" : { \"min\" : \"min value if other parameter is 'equal_value'\" } }, \"otherwise\" : { \"range\" : { \"min\" : \"min value if other parameter is not 'equal_value'\" } } } } }","title":"Members:"},{"location":"api/custom-adjust/","text":"Custom Adjustments The ParamTools adjustment format and logic can be augmented significantly. This is helpful for projects that need to support a pre-existing data format or require custom adjustment logic. Projects should customize their adjustments by writing their own adjust method and then calling the default adjust method from there: class Params ( paramtools . Parameters ): def adjust ( self , params_or_path , ** kwargs ): params = self . read_params ( params_or_path ) # ... custom logic here # call default adjust method. return super () . adjust ( params , ** kwargs ) Example Some projects may find it convenient to use CSVs for their adjustment format. That's no problem for ParamTools as long as the CSV is converted to a JSON file or Python dictionary that meets the ParamTools criteria. import io import os import pandas as pd import paramtools class CSVParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2000 , \"max\" : 2005 }} } } }, \"a\" : { \"title\" : \"A\" , \"description\" : \"a param\" , \"type\" : \"int\" , \"value\" : [ { \"year\" : 2000 , \"value\" : 1 }, { \"year\" : 2001 , \"value\" : 2 }, ] }, \"b\" : { \"title\" : \"B\" , \"description\" : \"b param\" , \"type\" : \"int\" , \"value\" : [ { \"year\" : 2000 , \"value\" : 3 }, { \"year\" : 2001 , \"value\" : 4 }, ] } } def adjust ( self , params_or_path , ** kwargs ): \"\"\" A custom adjust method that converts CSV files to ParamTools compliant Python dictionaries. \"\"\" if os . path . exists ( params_or_path ): paramsdf = pd . read_csv ( params_or_path , index_col = \"year\" ) else : paramsdf = pd . read_csv ( io . StringIO ( params_or_path ), index_col = \"year\" ) dfdict = paramsdf . to_dict () params = { \"a\" : [], \"b\" : []} for label in params : for year , value in dfdict [ label ] . items (): params [ label ] += [{ \"year\" : year , \"value\" : value }] # call adjust method on paramtools.Parameters which will # call _adjust to actually do the update. return super () . adjust ( params , ** kwargs ) Now we create an example CSV file. To keep the example self-contained, the CSV is just a string, but this example works with CSV files, too. The values of \"A\" are updated to 5 in 2000 and 6 in 2001, and the values of \"B\" are updated to 6 in 2000 and 7 in 2001. # this could also be a path to a CSV file. csv_string = \"\"\" year,a,b 2000,5,6 \\n 2001,6,7 \\n \"\"\" params = CSVParams () params . adjust ( csv_string ) # output # OrderedDict([('a', [{'year': 2000, 'value': 5}, {'year': 2001, 'value': 6}]), # ('b', [{'year': 2000, 'value': 6}, {'year': 2001, 'value': 7}])]) params . a # output: # [{'year': 2000, 'value': 5}, {'year': 2001, 'value': 6}] params . b # output # [{'year': 2000, 'value': 6}, {'year': 2001, 'value': 7}] Now, if we use array_first and label_to_extend , the params instance can be loaded into a Pandas DataFrame like this: csv_string = \"\"\" year,a,b 2000,5,6 \\n 2001,6,7 \\n \"\"\" params = CSVParams ( array_first = True , label_to_extend = \"year\" ) params . adjust ( csv_string ) # OrderedDict([('a', [{'value': 5, 'year': 2000}, {'value': 6, 'year': 2001}]), # ('b', [{'value': 6, 'year': 2000}, {'value': 7, 'year': 2001}])]) params_df = pd . DataFrame . from_dict ( params . to_dict ()) params_df # output: # a b # 0 5 6 # 1 6 7 # 2 6 7 # 3 6 7 # 4 6 7 # 5 6 7 params_df [ \"year\" ] = params . label_grid [ \"year\" ] params_df . set_index ( \"year\" ) # output: # a b # year # 2000 5 6 # 2001 6 7 # 2002 6 7 # 2003 6 7 # 2004 6 7 # 2005 6 7","title":"Custom Adjustments"},{"location":"api/custom-adjust/#custom-adjustments","text":"The ParamTools adjustment format and logic can be augmented significantly. This is helpful for projects that need to support a pre-existing data format or require custom adjustment logic. Projects should customize their adjustments by writing their own adjust method and then calling the default adjust method from there: class Params ( paramtools . Parameters ): def adjust ( self , params_or_path , ** kwargs ): params = self . read_params ( params_or_path ) # ... custom logic here # call default adjust method. return super () . adjust ( params , ** kwargs )","title":"Custom Adjustments"},{"location":"api/custom-adjust/#example","text":"Some projects may find it convenient to use CSVs for their adjustment format. That's no problem for ParamTools as long as the CSV is converted to a JSON file or Python dictionary that meets the ParamTools criteria. import io import os import pandas as pd import paramtools class CSVParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2000 , \"max\" : 2005 }} } } }, \"a\" : { \"title\" : \"A\" , \"description\" : \"a param\" , \"type\" : \"int\" , \"value\" : [ { \"year\" : 2000 , \"value\" : 1 }, { \"year\" : 2001 , \"value\" : 2 }, ] }, \"b\" : { \"title\" : \"B\" , \"description\" : \"b param\" , \"type\" : \"int\" , \"value\" : [ { \"year\" : 2000 , \"value\" : 3 }, { \"year\" : 2001 , \"value\" : 4 }, ] } } def adjust ( self , params_or_path , ** kwargs ): \"\"\" A custom adjust method that converts CSV files to ParamTools compliant Python dictionaries. \"\"\" if os . path . exists ( params_or_path ): paramsdf = pd . read_csv ( params_or_path , index_col = \"year\" ) else : paramsdf = pd . read_csv ( io . StringIO ( params_or_path ), index_col = \"year\" ) dfdict = paramsdf . to_dict () params = { \"a\" : [], \"b\" : []} for label in params : for year , value in dfdict [ label ] . items (): params [ label ] += [{ \"year\" : year , \"value\" : value }] # call adjust method on paramtools.Parameters which will # call _adjust to actually do the update. return super () . adjust ( params , ** kwargs ) Now we create an example CSV file. To keep the example self-contained, the CSV is just a string, but this example works with CSV files, too. The values of \"A\" are updated to 5 in 2000 and 6 in 2001, and the values of \"B\" are updated to 6 in 2000 and 7 in 2001. # this could also be a path to a CSV file. csv_string = \"\"\" year,a,b 2000,5,6 \\n 2001,6,7 \\n \"\"\" params = CSVParams () params . adjust ( csv_string ) # output # OrderedDict([('a', [{'year': 2000, 'value': 5}, {'year': 2001, 'value': 6}]), # ('b', [{'year': 2000, 'value': 6}, {'year': 2001, 'value': 7}])]) params . a # output: # [{'year': 2000, 'value': 5}, {'year': 2001, 'value': 6}] params . b # output # [{'year': 2000, 'value': 6}, {'year': 2001, 'value': 7}] Now, if we use array_first and label_to_extend , the params instance can be loaded into a Pandas DataFrame like this: csv_string = \"\"\" year,a,b 2000,5,6 \\n 2001,6,7 \\n \"\"\" params = CSVParams ( array_first = True , label_to_extend = \"year\" ) params . adjust ( csv_string ) # OrderedDict([('a', [{'value': 5, 'year': 2000}, {'value': 6, 'year': 2001}]), # ('b', [{'value': 6, 'year': 2000}, {'value': 7, 'year': 2001}])]) params_df = pd . DataFrame . from_dict ( params . to_dict ()) params_df # output: # a b # 0 5 6 # 1 6 7 # 2 6 7 # 3 6 7 # 4 6 7 # 5 6 7 params_df [ \"year\" ] = params . label_grid [ \"year\" ] params_df . set_index ( \"year\" ) # output: # a b # year # 2000 5 6 # 2001 6 7 # 2002 6 7 # 2003 6 7 # 2004 6 7 # 2005 6 7","title":"Example"},{"location":"api/custom-types/","text":"Custom Types Often, the behavior for a field needs to be customized to support a particular shape or validation method that ParamTools does not support out of the box. In this case, you may use the register_custom_type function to add your new type to the ParamTools type registry. Each type has a corresponding field that is used for serialization and deserialization. ParamTools will then use this field any time it is handling a value , label , or member that is of this type . ParamTools is built on top of marshmallow , a general purpose validation library. This means that you must implement a custom marshmallow field to go along with your new type. Please refer to the marshmallow docs if you have questions about the use of marshmallow in the examples below. 32 Bit Integer Example ParamTools's default integer field uses NumPy's int64 type. This example shows you how to define an int32 type and reference it in your defaults . First, let's define the Marshmallow class: import marshmallow as ma import numpy as np class Int32 ( ma . fields . Field ): \"\"\" A custom type for np.int32. https://numpy.org/devdocs/reference/arrays.dtypes.html \"\"\" # minor detail that makes this play nice with array_first np_type = np . int32 def _serialize ( self , value , * args , ** kwargs ): \"\"\"Convert np.int32 to basic, serializable Python int.\"\"\" return value . tolist () def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) return converted Now, reference it in our defaults JSON/dict object: import paramtools as pt # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , Int32 ()) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 } } params = Params ( array_first = True ) print ( f \"value: {params.small_int} , type: {type(params.small_int)}\" ) # value: 2, type: <class 'numpy.int32'> One problem with this is that we could run into some deserialization issues. Due to integer overflow, our deserialized result is not the number that we passed in--it's negative! params . adjust ( dict ( # this number wasn't chosen randomly. small_int = 2147483647 + 1 )) # OrderedDict([('small_int', [{'value': -2147483648}])]) Marshmallow Validator Fortunately, you can specify a custom validator with marshmallow or ParamTools. Making this works requires modifying the _deserialize method to check for overflow like this: # check out the full example at the bottom of this page. def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) # check for overflow and let range validator # display the error message. if converted != int ( value ): return int ( value ) return converted Now, let's see how to use marshmallow to fix this problem: import marshmallow as ma import paramtools as pt # get the minimum and maxium values for 32 bit integers. min_int32 = - 2147483648 # = np.iinfo(np.int32).min max_int32 = 2147483647 # = np.iinfo(np.int32).max # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , Int32 ( validate = [ ma . validate . Range ( min = min_int32 , max = max_int32 ) ]) ) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 } } params = Params ( array_first = True ) params . adjust ( dict ( small_int = np . int64 ( max_int32 ) + 1 )) # ValidationError: { # \"errors\": { # \"small_int\": [ # \"Must be greater than or equal to -2147483648 and less than or equal to 2147483647.\" # ] # } # } ParamTools Validator Finally, we will use ParamTools to solve this problem. We need to modify how we create our custom marshmallow field so that it's wrapped by ParamTools's PartialField . This makes it clear that your field still needs to be initialized, and that your custom field is able to receive validation information from the defaults configuration: import paramtools as pt # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , pt . PartialField ( Int32 ) ) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 , \"validators\" : { \"range\" : { \"min\" : - 2147483648 , \"max\" : 2147483647 } } } } params = Params ( array_first = True ) params . adjust ( dict ( small_int = 2147483647 + 1 )) # ValidationError: { # \"errors\": { # \"small_int\": [ # \"small_int 2147483648 > max 2147483647 \" # ] # } # } Complete Int32 field import marshmallow as ma import numpy as np class Int32 ( ma . fields . Field ): \"\"\" A custom type for np.int32. https://numpy.org/devdocs/reference/arrays.dtypes.html \"\"\" # minor detail that makes this play nice with array_first np_type = np . int32 def _serialize ( self , value , * args , ** kwargs ): \"\"\"Convert np.int32 to basic Python int.\"\"\" return value . tolist () def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) # check for overflow and let range validator # display the error message. if converted != int ( value ): return int ( value ) return converted","title":"Custom Types"},{"location":"api/custom-types/#custom-types","text":"Often, the behavior for a field needs to be customized to support a particular shape or validation method that ParamTools does not support out of the box. In this case, you may use the register_custom_type function to add your new type to the ParamTools type registry. Each type has a corresponding field that is used for serialization and deserialization. ParamTools will then use this field any time it is handling a value , label , or member that is of this type . ParamTools is built on top of marshmallow , a general purpose validation library. This means that you must implement a custom marshmallow field to go along with your new type. Please refer to the marshmallow docs if you have questions about the use of marshmallow in the examples below.","title":"Custom Types"},{"location":"api/custom-types/#32-bit-integer-example","text":"ParamTools's default integer field uses NumPy's int64 type. This example shows you how to define an int32 type and reference it in your defaults . First, let's define the Marshmallow class: import marshmallow as ma import numpy as np class Int32 ( ma . fields . Field ): \"\"\" A custom type for np.int32. https://numpy.org/devdocs/reference/arrays.dtypes.html \"\"\" # minor detail that makes this play nice with array_first np_type = np . int32 def _serialize ( self , value , * args , ** kwargs ): \"\"\"Convert np.int32 to basic, serializable Python int.\"\"\" return value . tolist () def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) return converted Now, reference it in our defaults JSON/dict object: import paramtools as pt # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , Int32 ()) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 } } params = Params ( array_first = True ) print ( f \"value: {params.small_int} , type: {type(params.small_int)}\" ) # value: 2, type: <class 'numpy.int32'> One problem with this is that we could run into some deserialization issues. Due to integer overflow, our deserialized result is not the number that we passed in--it's negative! params . adjust ( dict ( # this number wasn't chosen randomly. small_int = 2147483647 + 1 )) # OrderedDict([('small_int', [{'value': -2147483648}])])","title":"32 Bit Integer Example"},{"location":"api/custom-types/#marshmallow-validator","text":"Fortunately, you can specify a custom validator with marshmallow or ParamTools. Making this works requires modifying the _deserialize method to check for overflow like this: # check out the full example at the bottom of this page. def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) # check for overflow and let range validator # display the error message. if converted != int ( value ): return int ( value ) return converted Now, let's see how to use marshmallow to fix this problem: import marshmallow as ma import paramtools as pt # get the minimum and maxium values for 32 bit integers. min_int32 = - 2147483648 # = np.iinfo(np.int32).min max_int32 = 2147483647 # = np.iinfo(np.int32).max # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , Int32 ( validate = [ ma . validate . Range ( min = min_int32 , max = max_int32 ) ]) ) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 } } params = Params ( array_first = True ) params . adjust ( dict ( small_int = np . int64 ( max_int32 ) + 1 )) # ValidationError: { # \"errors\": { # \"small_int\": [ # \"Must be greater than or equal to -2147483648 and less than or equal to 2147483647.\" # ] # } # }","title":"Marshmallow Validator"},{"location":"api/custom-types/#paramtools-validator","text":"Finally, we will use ParamTools to solve this problem. We need to modify how we create our custom marshmallow field so that it's wrapped by ParamTools's PartialField . This makes it clear that your field still needs to be initialized, and that your custom field is able to receive validation information from the defaults configuration: import paramtools as pt # add int32 type to the paramtools type registry pt . register_custom_type ( \"int32\" , pt . PartialField ( Int32 ) ) class Params ( pt . Parameters ): defaults = { \"small_int\" : { \"title\" : \"Small integer\" , \"description\" : \"Demonstrate how to define a custom type\" , \"type\" : \"int32\" , \"value\" : 2 , \"validators\" : { \"range\" : { \"min\" : - 2147483648 , \"max\" : 2147483647 } } } } params = Params ( array_first = True ) params . adjust ( dict ( small_int = 2147483647 + 1 )) # ValidationError: { # \"errors\": { # \"small_int\": [ # \"small_int 2147483648 > max 2147483647 \" # ] # } # }","title":"ParamTools Validator"},{"location":"api/custom-types/#complete-int32-field","text":"import marshmallow as ma import numpy as np class Int32 ( ma . fields . Field ): \"\"\" A custom type for np.int32. https://numpy.org/devdocs/reference/arrays.dtypes.html \"\"\" # minor detail that makes this play nice with array_first np_type = np . int32 def _serialize ( self , value , * args , ** kwargs ): \"\"\"Convert np.int32 to basic Python int.\"\"\" return value . tolist () def _deserialize ( self , value , * args , ** kwargs ): \"\"\"Cast value from JSON to NumPy Int32.\"\"\" converted = np . int32 ( value ) # check for overflow and let range validator # display the error message. if converted != int ( value ): return int ( value ) return converted","title":"Complete Int32 field"},{"location":"api/extend/","text":"Extend The values of a parameter can be extended along a specified label. This is helpful when a parameter's values are the same for different values of a label and there is some inherent order in that label. The extend feature allows you to simply write down the minimum amount of information needed to fill in a parameter's values and ParamTools will fill in the gaps. To use the extend feature, set the label_to_extend class attribute to the label that should be extended. Example The standard deduction parameter's values only need to be specified when there is a change in the tax law. For the other years, it does not change (unless its indexed to inflation). It would be annoying to have to manually write out each of its values. Instead, we can more concisely write its values in 2017, its new values in 2018 after the TCJA tax reform was passed, and its values after provisions of the TCJA are phased out in 2026. import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2017 , \"marital_status\" : \"single\" , \"value\" : 6350 }, { \"year\" : 2017 , \"marital_status\" : \"joint\" , \"value\" : 12700 }, { \"year\" : 2018 , \"marital_status\" : \"single\" , \"value\" : 12000 }, { \"year\" : 2018 , \"marital_status\" : \"joint\" , \"value\" : 24000 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7685 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15369 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } label_to_extend = \"year\" array_first = True params = TaxParams () params . standard_deduction # output: # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [ 7685., 15369.], # [ 7685., 15369.]]) Adjustments are also extended along label_to_extend . In the example below, standard_deduction is set to 10,000 in 2017, increased to 15,000 for single tax units in 2020, and increased to 20,000 for joint tax units in 2021: params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] } ) params . standard_deduction # output # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [10000., 10000.], # [10000., 10000.], # [10000., 10000.], # [15000., 10000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.]]) Clobber In the previous example, the new values clobber the existing values in years after they are specified. By setting clobber to False , only values that were added automatically will be replaced by the new ones. User defined values such as those in 2026 will not be over-written by the new values: params = TaxParams () params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] }, clobber = False , ) params . standard_deduction # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [10000., 10000.], # [12000., 24000.], # [12000., 24000.], # [15000., 24000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [ 7685., 15369.], # [ 7685., 15369.]]) Extend behavior by validator ParamTools uses the validator associated with label_to_extend to determine how values should be extended by assuming that there is some order among the range of possible values for the label. Note: You can view the grid of values for any label by inspecting the label_grid attribute of a paramtools.Parameters derived instance. Range Type: int { \"range\" : { \"min\" : 0 , \"max\" : 5 } } Extend values: [ 0 , 1 , 2 , 3 , 4 , 5 ] Type: float { \"range\" : { \"min\" : 0 , \"max\" : 2 , \"step\" : 0.5 } } Extend values: [ 0 , 0.5 , 1.0 , 1.5 , 2.0 ] Type: date { \"range\" : { \"min\" : \"2019-01-01\" , \"max\" : \"2019-01-05\" , \"step\" : { \"days\" : 2 } } } Extend values: [ datetime . date ( 2019 , 1 , 1 ), datetime . date ( 2019 , 1 , 3 ), datetime . date ( 2019 , 1 , 5 )] Choice Type: int { \"choice\" : { \"choices\" : [ -1 , -2 , -3 ] } } Extend values: [ - 1 , - 2 , - 3 ] Type: str { \"choice\" : { \"choices\" : [ \"january\" , \"february\" , \"march\" ] } } Extend values: [ \"january\" , \"february\" , \"march\" ]","title":"Extend"},{"location":"api/extend/#extend","text":"The values of a parameter can be extended along a specified label. This is helpful when a parameter's values are the same for different values of a label and there is some inherent order in that label. The extend feature allows you to simply write down the minimum amount of information needed to fill in a parameter's values and ParamTools will fill in the gaps. To use the extend feature, set the label_to_extend class attribute to the label that should be extended.","title":"Extend"},{"location":"api/extend/#example","text":"The standard deduction parameter's values only need to be specified when there is a change in the tax law. For the other years, it does not change (unless its indexed to inflation). It would be annoying to have to manually write out each of its values. Instead, we can more concisely write its values in 2017, its new values in 2018 after the TCJA tax reform was passed, and its values after provisions of the TCJA are phased out in 2026. import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"type\" : \"float\" , \"value\" : [ { \"year\" : 2017 , \"marital_status\" : \"single\" , \"value\" : 6350 }, { \"year\" : 2017 , \"marital_status\" : \"joint\" , \"value\" : 12700 }, { \"year\" : 2018 , \"marital_status\" : \"single\" , \"value\" : 12000 }, { \"year\" : 2018 , \"marital_status\" : \"joint\" , \"value\" : 24000 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7685 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15369 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } label_to_extend = \"year\" array_first = True params = TaxParams () params . standard_deduction # output: # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [12000., 24000.], # [ 7685., 15369.], # [ 7685., 15369.]]) Adjustments are also extended along label_to_extend . In the example below, standard_deduction is set to 10,000 in 2017, increased to 15,000 for single tax units in 2020, and increased to 20,000 for joint tax units in 2021: params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] } ) params . standard_deduction # output # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [10000., 10000.], # [10000., 10000.], # [10000., 10000.], # [15000., 10000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.]])","title":"Example"},{"location":"api/extend/#clobber","text":"In the previous example, the new values clobber the existing values in years after they are specified. By setting clobber to False , only values that were added automatically will be replaced by the new ones. User defined values such as those in 2026 will not be over-written by the new values: params = TaxParams () params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] }, clobber = False , ) params . standard_deduction # array([[ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [ 6350., 12700.], # [10000., 10000.], # [12000., 24000.], # [12000., 24000.], # [15000., 24000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [15000., 20000.], # [ 7685., 15369.], # [ 7685., 15369.]])","title":"Clobber"},{"location":"api/extend/#extend-behavior-by-validator","text":"ParamTools uses the validator associated with label_to_extend to determine how values should be extended by assuming that there is some order among the range of possible values for the label. Note: You can view the grid of values for any label by inspecting the label_grid attribute of a paramtools.Parameters derived instance.","title":"Extend behavior by validator"},{"location":"api/extend/#range","text":"Type: int { \"range\" : { \"min\" : 0 , \"max\" : 5 } } Extend values: [ 0 , 1 , 2 , 3 , 4 , 5 ] Type: float { \"range\" : { \"min\" : 0 , \"max\" : 2 , \"step\" : 0.5 } } Extend values: [ 0 , 0.5 , 1.0 , 1.5 , 2.0 ] Type: date { \"range\" : { \"min\" : \"2019-01-01\" , \"max\" : \"2019-01-05\" , \"step\" : { \"days\" : 2 } } } Extend values: [ datetime . date ( 2019 , 1 , 1 ), datetime . date ( 2019 , 1 , 3 ), datetime . date ( 2019 , 1 , 5 )]","title":"Range"},{"location":"api/extend/#choice","text":"Type: int { \"choice\" : { \"choices\" : [ -1 , -2 , -3 ] } } Extend values: [ - 1 , - 2 , - 3 ] Type: str { \"choice\" : { \"choices\" : [ \"january\" , \"february\" , \"march\" ] } } Extend values: [ \"january\" , \"february\" , \"march\" ]","title":"Choice"},{"location":"api/guide/","text":"Guide Just getting started? Check out the home page for a quick start guide. Want to learn more about the JSON spec? Check out the parameters spec to learn more about what types of parameters and validators are supported by ParamTools. API Extend: Write more concise JSON schemas with the extend capability. Extend with Indexing: Index parameter values. Custom Adjustment Formats and Logic Customize the adjustment format and logic to meet your project's needs. Custom types Add custom types for your parameters' values, labels, and members. Documentation on these parts of the API coming soon: Array access: Access parameter values as NumPy arrays. Query: Powerful query language for selecting parameter values based on their associated labels.","title":"Guide"},{"location":"api/guide/#guide","text":"Just getting started? Check out the home page for a quick start guide. Want to learn more about the JSON spec? Check out the parameters spec to learn more about what types of parameters and validators are supported by ParamTools.","title":"Guide"},{"location":"api/guide/#api","text":"Extend: Write more concise JSON schemas with the extend capability. Extend with Indexing: Index parameter values. Custom Adjustment Formats and Logic Customize the adjustment format and logic to meet your project's needs. Custom types Add custom types for your parameters' values, labels, and members. Documentation on these parts of the API coming soon: Array access: Access parameter values as NumPy arrays. Query: Powerful query language for selecting parameter values based on their associated labels.","title":"API"},{"location":"api/indexing/","text":"Extend with Indexing ParamTools provides out-of-the-box parameter indexing. This is helpful for projects that have parameters that change at some rate over time. For example, tax parameters like the standard deduction are often indexed to price inflation. So, the value of the standard deduction actually increases every year by 1 or 2% depending on that year's inflation rate. The extend documentation may be useful for gaining a better understanding of how ParamTools extends parameter values along label_to_extend . To use the indexing feature: Set the label_to_extend class attribute to the label that should be extended Set the indexing_rates class attribute to a dictionary of inflation rates where the keys correspond to the value of label_to_extend and the values are the indexing rates. Set the uses_extend_func class attribute to True . In defaults or defaults.json , set indexed to True for each parameter that needs to be indexed. Example This is a continuation of the tax parameters example from the extend documentation . The differences are indexed is set to True for the standard_deducation parameter, uses_extend_func is set to True , and index_rates is specified with inflation rates obtained from the open-source tax modeling package, Tax-Calculator , using version 2.5.0. import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"type\" : \"float\" , # Set indexed to True to extend standard_deduction with the built-in # extension logic. \"indexed\" : True , \"value\" : [ { \"year\" : 2017 , \"marital_status\" : \"single\" , \"value\" : 6350 }, { \"year\" : 2017 , \"marital_status\" : \"joint\" , \"value\" : 12700 }, { \"year\" : 2018 , \"marital_status\" : \"single\" , \"value\" : 12000 }, { \"year\" : 2018 , \"marital_status\" : \"joint\" , \"value\" : 24000 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7685 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15369 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } array_first = True label_to_extend = \"year\" # Activate use of extend_func method. uses_extend_func = True # inflation rates from Tax-Calculator v2.5.0 index_rates = { 2013 : 0.0148 , 2014 : 0.0159 , 2015 : 0.0012 , 2016 : 0.0127 , 2017 : 0.0187 , 2018 : 0.0224 , 2019 : 0.0186 , 2020 : 0.0233 , 2021 : 0.0229 , 2022 : 0.0228 , 2023 : 0.0221 , 2024 : 0.0211 , 2025 : 0.0209 , 2026 : 0.0211 , 2027 : 0.0208 , 2028 : 0.021 , 2029 : 0.021 } params = TaxParams () params . standard_deduction # output: # array([[ 6074.92, 12149.84], # [ 6164.83, 12329.66], # [ 6262.85, 12525.7 ], # [ 6270.37, 12540.73], # [ 6350. , 12700. ], # [12000. , 24000. ], # [12268.8 , 24537.6 ], # [12497. , 24994. ], # [12788.18, 25576.36], # [13081.03, 26162.06], # [13379.28, 26758.55], # [13674.96, 27349.91], # [13963.5 , 27926.99], # [ 7685. , 15369. ], # [ 7847.15, 15693.29]]) Adjustments are also indexed. In the example below, standard_deduction is set to 10,000 in 2017, increased to 15,000 for single tax units in 2020, and increased to 20,000 for joint tax units in 2021: params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] } ) params . standard_deduction # output: # array([[ 6074.92, 12149.84], # [ 6164.83, 12329.66], # [ 6262.85, 12525.7 ], # [ 6270.37, 12540.73], # [10000. , 10000. ], # [10187. , 10187. ], # [10415.19, 10415.19], # [15000. , 10608.91], # [15349.5 , 20000. ], # [15701. , 20458. ], # [16058.98, 20924.44], # [16413.88, 21386.87], # [16760.21, 21838.13], # [17110.5 , 22294.55], # [17471.53, 22764.97]]) All values that are added automatically via the extend method are given an _auto attribute. You can select them like this: params = TaxParams () params . select_eq ( \"standard_deduction\" , strict = True , _auto = True ) # [{'_auto': True, 'marital_status': 'single', 'year': 2013, 'value': 5840.42}, # {'_auto': True, 'marital_status': 'single', 'year': 2014, 'value': 5985.26}, # {'_auto': True, 'marital_status': 'single', 'year': 2015, 'value': 6140.28}, # {'_auto': True, 'marital_status': 'single', 'year': 2016, 'value': 6209.05}, # {'_auto': True, 'marital_status': 'single', 'year': 2019, 'value': 12388.8}, # {'_auto': True, 'marital_status': 'single', 'year': 2020, 'value': 12743.12}, # {'_auto': True, 'marital_status': 'single', 'year': 2021, 'value': 13167.47}, # {'_auto': True, 'marital_status': 'single', 'year': 2022, 'value': 13600.68}, # {'_auto': True, 'marital_status': 'single', 'year': 2023, 'value': 14046.78}, # {'_auto': True, 'marital_status': 'single', 'year': 2024, 'value': 14497.68}, # {'_auto': True, 'marital_status': 'single', 'year': 2025, 'value': 14948.56}, # {'_auto': True, 'marital_status': 'single', 'year': 2027, 'value': 7924.0}, # {'_auto': True, 'marital_status': 'joint', 'year': 2013, 'value': 11680.85}, # {'_auto': True, 'marital_status': 'joint', 'year': 2014, 'value': 11970.54}, # {'_auto': True, 'marital_status': 'joint', 'year': 2015, 'value': 12280.58}, # {'_auto': True, 'marital_status': 'joint', 'year': 2016, 'value': 12418.12}, # {'_auto': True, 'marital_status': 'joint', 'year': 2019, 'value': 24777.6}, # {'_auto': True, 'marital_status': 'joint', 'year': 2020, 'value': 25486.24}, # {'_auto': True, 'marital_status': 'joint', 'year': 2021, 'value': 26334.93}, # {'_auto': True, 'marital_status': 'joint', 'year': 2022, 'value': 27201.35}, # {'_auto': True, 'marital_status': 'joint', 'year': 2023, 'value': 28093.55}, # {'_auto': True, 'marital_status': 'joint', 'year': 2024, 'value': 28995.35}, # {'_auto': True, 'marital_status': 'joint', 'year': 2025, 'value': 29897.11}, # {'_auto': True, 'marital_status': 'joint', 'year': 2027, 'value': 15846.98}] If you want to update the index rates and apply them to your existing values, then all you need to do is remove the values that were added automatically. ParamTools will fill in the missing values using the updated index rates: params = TaxParams () offset = 0.0025 for year , rate in params . index_rates . items (): params . index_rates [ year ] = rate + offset automatically_added = params . select_eq ( \"standard_deduction\" , strict = True , _auto = True ) params . delete ( { \"standard_deduction\" : automatically_added } ) params . standard_deduction # array([[ 5783.57, 11567.15], # [ 5941.46, 11882.93], # [ 6110.2 , 12220.41], # [ 6193.91, 12387.83], # [ 6350. , 12700. ], # [12000. , 24000. ], # [12418.8 , 24837.6 ], # [12805.02, 25610.05], # [13263.44, 26526.89], # [13732.97, 27465.94], # [14217.74, 28435.49], # [14709.67, 29419.36], # [15203.91, 30407.85], # [ 7685. , 15369. ], # [ 7943.22, 15885.4 ]]) Code for getting Tax-Calculator index rates import taxcalc pol = taxcalc . Policy () index_rates = { year : value for year , value in zip ( list ( range ( 2013 , 2029 + 1 )), pol . inflation_rates ()) } Note that there are some subtle details that are implemented in Tax-Calculator's indexing logic that are not implemented in this example. Tax-Calculator has a parameter called CPI_offset that adjusts inflation rates up or down by a fixed amount. The indexed property can also be turned on and off for each parameter. Implementing these nuanced features is left as the proverbial \"trivial exercise to the reader.\"","title":"Extend with Indexing"},{"location":"api/indexing/#extend-with-indexing","text":"ParamTools provides out-of-the-box parameter indexing. This is helpful for projects that have parameters that change at some rate over time. For example, tax parameters like the standard deduction are often indexed to price inflation. So, the value of the standard deduction actually increases every year by 1 or 2% depending on that year's inflation rate. The extend documentation may be useful for gaining a better understanding of how ParamTools extends parameter values along label_to_extend . To use the indexing feature: Set the label_to_extend class attribute to the label that should be extended Set the indexing_rates class attribute to a dictionary of inflation rates where the keys correspond to the value of label_to_extend and the values are the indexing rates. Set the uses_extend_func class attribute to True . In defaults or defaults.json , set indexed to True for each parameter that needs to be indexed.","title":"Extend with Indexing"},{"location":"api/indexing/#example","text":"This is a continuation of the tax parameters example from the extend documentation . The differences are indexed is set to True for the standard_deducation parameter, uses_extend_func is set to True , and index_rates is specified with inflation rates obtained from the open-source tax modeling package, Tax-Calculator , using version 2.5.0. import paramtools class TaxParams ( paramtools . Parameters ): defaults = { \"schema\" : { \"labels\" : { \"year\" : { \"type\" : \"int\" , \"validators\" : { \"range\" : { \"min\" : 2013 , \"max\" : 2027 }} }, \"marital_status\" : { \"type\" : \"str\" , \"validators\" : { \"choice\" : { \"choices\" : [ \"single\" , \"joint\" ]}} }, } }, \"standard_deduction\" : { \"title\" : \"Standard deduction amount\" , \"description\" : \"Amount filing unit can use as a standard deduction.\" , \"type\" : \"float\" , # Set indexed to True to extend standard_deduction with the built-in # extension logic. \"indexed\" : True , \"value\" : [ { \"year\" : 2017 , \"marital_status\" : \"single\" , \"value\" : 6350 }, { \"year\" : 2017 , \"marital_status\" : \"joint\" , \"value\" : 12700 }, { \"year\" : 2018 , \"marital_status\" : \"single\" , \"value\" : 12000 }, { \"year\" : 2018 , \"marital_status\" : \"joint\" , \"value\" : 24000 }, { \"year\" : 2026 , \"marital_status\" : \"single\" , \"value\" : 7685 }, { \"year\" : 2026 , \"marital_status\" : \"joint\" , \"value\" : 15369 }], \"validators\" : { \"range\" : { \"min\" : 0 , \"max\" : 9e+99 } } }, } array_first = True label_to_extend = \"year\" # Activate use of extend_func method. uses_extend_func = True # inflation rates from Tax-Calculator v2.5.0 index_rates = { 2013 : 0.0148 , 2014 : 0.0159 , 2015 : 0.0012 , 2016 : 0.0127 , 2017 : 0.0187 , 2018 : 0.0224 , 2019 : 0.0186 , 2020 : 0.0233 , 2021 : 0.0229 , 2022 : 0.0228 , 2023 : 0.0221 , 2024 : 0.0211 , 2025 : 0.0209 , 2026 : 0.0211 , 2027 : 0.0208 , 2028 : 0.021 , 2029 : 0.021 } params = TaxParams () params . standard_deduction # output: # array([[ 6074.92, 12149.84], # [ 6164.83, 12329.66], # [ 6262.85, 12525.7 ], # [ 6270.37, 12540.73], # [ 6350. , 12700. ], # [12000. , 24000. ], # [12268.8 , 24537.6 ], # [12497. , 24994. ], # [12788.18, 25576.36], # [13081.03, 26162.06], # [13379.28, 26758.55], # [13674.96, 27349.91], # [13963.5 , 27926.99], # [ 7685. , 15369. ], # [ 7847.15, 15693.29]]) Adjustments are also indexed. In the example below, standard_deduction is set to 10,000 in 2017, increased to 15,000 for single tax units in 2020, and increased to 20,000 for joint tax units in 2021: params . adjust ( { \"standard_deduction\" : [ { \"year\" : 2017 , \"value\" : 10000 }, { \"year\" : 2020 , \"marital_status\" : \"single\" , \"value\" : 15000 }, { \"year\" : 2021 , \"marital_status\" : \"joint\" , \"value\" : 20000 } ] } ) params . standard_deduction # output: # array([[ 6074.92, 12149.84], # [ 6164.83, 12329.66], # [ 6262.85, 12525.7 ], # [ 6270.37, 12540.73], # [10000. , 10000. ], # [10187. , 10187. ], # [10415.19, 10415.19], # [15000. , 10608.91], # [15349.5 , 20000. ], # [15701. , 20458. ], # [16058.98, 20924.44], # [16413.88, 21386.87], # [16760.21, 21838.13], # [17110.5 , 22294.55], # [17471.53, 22764.97]]) All values that are added automatically via the extend method are given an _auto attribute. You can select them like this: params = TaxParams () params . select_eq ( \"standard_deduction\" , strict = True , _auto = True ) # [{'_auto': True, 'marital_status': 'single', 'year': 2013, 'value': 5840.42}, # {'_auto': True, 'marital_status': 'single', 'year': 2014, 'value': 5985.26}, # {'_auto': True, 'marital_status': 'single', 'year': 2015, 'value': 6140.28}, # {'_auto': True, 'marital_status': 'single', 'year': 2016, 'value': 6209.05}, # {'_auto': True, 'marital_status': 'single', 'year': 2019, 'value': 12388.8}, # {'_auto': True, 'marital_status': 'single', 'year': 2020, 'value': 12743.12}, # {'_auto': True, 'marital_status': 'single', 'year': 2021, 'value': 13167.47}, # {'_auto': True, 'marital_status': 'single', 'year': 2022, 'value': 13600.68}, # {'_auto': True, 'marital_status': 'single', 'year': 2023, 'value': 14046.78}, # {'_auto': True, 'marital_status': 'single', 'year': 2024, 'value': 14497.68}, # {'_auto': True, 'marital_status': 'single', 'year': 2025, 'value': 14948.56}, # {'_auto': True, 'marital_status': 'single', 'year': 2027, 'value': 7924.0}, # {'_auto': True, 'marital_status': 'joint', 'year': 2013, 'value': 11680.85}, # {'_auto': True, 'marital_status': 'joint', 'year': 2014, 'value': 11970.54}, # {'_auto': True, 'marital_status': 'joint', 'year': 2015, 'value': 12280.58}, # {'_auto': True, 'marital_status': 'joint', 'year': 2016, 'value': 12418.12}, # {'_auto': True, 'marital_status': 'joint', 'year': 2019, 'value': 24777.6}, # {'_auto': True, 'marital_status': 'joint', 'year': 2020, 'value': 25486.24}, # {'_auto': True, 'marital_status': 'joint', 'year': 2021, 'value': 26334.93}, # {'_auto': True, 'marital_status': 'joint', 'year': 2022, 'value': 27201.35}, # {'_auto': True, 'marital_status': 'joint', 'year': 2023, 'value': 28093.55}, # {'_auto': True, 'marital_status': 'joint', 'year': 2024, 'value': 28995.35}, # {'_auto': True, 'marital_status': 'joint', 'year': 2025, 'value': 29897.11}, # {'_auto': True, 'marital_status': 'joint', 'year': 2027, 'value': 15846.98}] If you want to update the index rates and apply them to your existing values, then all you need to do is remove the values that were added automatically. ParamTools will fill in the missing values using the updated index rates: params = TaxParams () offset = 0.0025 for year , rate in params . index_rates . items (): params . index_rates [ year ] = rate + offset automatically_added = params . select_eq ( \"standard_deduction\" , strict = True , _auto = True ) params . delete ( { \"standard_deduction\" : automatically_added } ) params . standard_deduction # array([[ 5783.57, 11567.15], # [ 5941.46, 11882.93], # [ 6110.2 , 12220.41], # [ 6193.91, 12387.83], # [ 6350. , 12700. ], # [12000. , 24000. ], # [12418.8 , 24837.6 ], # [12805.02, 25610.05], # [13263.44, 26526.89], # [13732.97, 27465.94], # [14217.74, 28435.49], # [14709.67, 29419.36], # [15203.91, 30407.85], # [ 7685. , 15369. ], # [ 7943.22, 15885.4 ]])","title":"Example"},{"location":"api/indexing/#code-for-getting-tax-calculator-index-rates","text":"import taxcalc pol = taxcalc . Policy () index_rates = { year : value for year , value in zip ( list ( range ( 2013 , 2029 + 1 )), pol . inflation_rates ()) } Note that there are some subtle details that are implemented in Tax-Calculator's indexing logic that are not implemented in this example. Tax-Calculator has a parameter called CPI_offset that adjusts inflation rates up or down by a fixed amount. The indexed property can also be turned on and off for each parameter. Implementing these nuanced features is left as the proverbial \"trivial exercise to the reader.\"","title":"Code for getting Tax-Calculator index rates"},{"location":"api/reference/","text":"API documentation class paramtools. Parameters ( initial_state=None , index_rates=None , **ops ) adjust ( self , params_or_path , ignore_warnings=False , raise_errors=True , extend_adj=True , clobber=True ) Deserialize and validate parameter adjustments. params_or_path can be a file path or a dict that has not been fully deserialized. The adjusted values replace the current values stored in the corresponding parameter attributes. If clobber is True and extend mode is on, then all future values for a given parameter be replaced by the values in the adjustment. If clobber is False and extend mode is on, then user-defined values will not be replaced by values in this adjustment. Only values that were added automatically via the extend method will be updated. This simply calls a private method _adjust to do the upate. Creating this layer on top of _adjust makes it easy to subclass Parameters and implement custom adjust methods. Parameters params_or_path : Adjustment that is either a dict , file path, or JSON string. ignore_warnings : Whether to raise an error on warnings or ignore them. raise_errors : Either raise errors or simply store the error messages. extend_adj : If in extend mode, this is a flag indicating whether to extend the adjustment values or not. clobber : If in extend mode, this is a flag indicating whether to override all values, including user-defined values, or to only override automatically created values. Returns params : Parsed, validated parameters. Raises marshmallow.exceptions.ValidationError if data is not valid. ParameterUpdateException if label values do not match at least one existing value item's corresponding label values. read_params ( self , params_or_path , storage_options=None ) Read JSON data of the form: Python dict . JSON string. Local file path. Any URL readable by fsspec. For example: s3: s3://paramtools-test/defaults.json gcs: gs://paramtools-dev/defaults.json http: https://somedomain.com/defaults.json github: github://PSLmodels:ParamTools@master/paramtools/tests/defaults.json Returns - params : Python Dict created from JSON file. set_state ( self , **labels ) Sets state for the Parameters instance. The _state , label_grid , and parameter attributes are all updated with the new state. Use the view_state method to inspect the current state of the instance, and use the clear_state method to revert to the default state. Raises ValidationError if the labels kwargs contain labels that are not specified in schema.json or if the label values fail the validator set for the corresponding label in schema.json. view_state ( self ) Access the label state of the Parameters instance. clear_state ( self ) Reset the state of the Parameters instance. specification ( self , use_state=True , meta_data=False , include_empty=False , serializable=False , sort_values=False , **labels ) Query value(s) of all parameters along labels specified in labels . Parameters use_state : Use the instance's state for the select operation. meta_data : Include information like the parameter description and title. include_empty : Include parameters that do not meet the label query. serializable : Return data that is compatible with json.dumps . sort_values : Sort values by the label order. Returns dict of parameter names and data. extend ( self , label=None , label_values=None , params=None , raise_errors=True , ignore_warnings=False ) Extend parameters along label . Parameters label : Label to extend values along. By default, label_to_extend is used. label_values : values of label to extend. By default, this is a grid created from the valid values of label_to_extend . params : Parameters to extend. By default, all parameters are extended. raise_errors : Whether adjust should raise or store errors. ignore_warnings : Whether adjust should raise or ignore warnings. Raises InconsistentLabelsException : Value objects do not have consistent labels. extend_func ( self , param , extend_vo , known_vo , extend_grid , label ) Function for applying indexing rates to parameter values as they are extended. Projects may implement their own extend_func by overriding this one. Projects need to write their own indexing_rate method for returning the correct indexing rate for a given parameter and value of label . Returns extend_vo : New ValueObject . to_array ( self , param , **labels ) Convert a Value object to an n-labelal array. The list of Value objects must span the specified parameter space. The parameter space is defined by inspecting the label validators in schema.json and the state attribute of the Parameters instance. Parameters - param : Name of parameter that will be used to create array. - labels : Optionally, override instance state. Returns arr : NumPy array created from list of value objects. Raises InconsistentLabelsException : Value objects do not have consistent labels. SparseValueObjectsException : Value object does not span the entire space specified by the Order object. ParamToolsError : Parameter is an array type and has labels. This is not supported by ParamTools when using array_first. from_array ( self , param , array=None , **labels ) Convert NumPy array to a Value object. Parameters param : Name of parameter to convert to a list of value objects. array : Optionally, provide a NumPy array to convert into a list of value objects. If not specified, the value at self.param will be used. labels : Optionally, override instance state. Returns List of ValueObjects Raises InconsistentLabelsException : Value objects do not have consistent labels. parse_labels ( self , **labels ) Parse and validate labels. Returns Parsed and validated labels. sort_values ( self , data=None , has_meta_data=True ) Sort value objects for all parameters in data according to the order specified in schema . Parameters data : Parameter data to be sorted. This should be a dict of parameter names and values. If data is None , the current values will be sorted. has_meta_data : Whether parameter values should be accessed directly or through the \"value\" attribute. Returns Sorted data.","title":"Reference"},{"location":"api/reference/#api-documentation","text":"class paramtools. Parameters ( initial_state=None , index_rates=None , **ops ) adjust ( self , params_or_path , ignore_warnings=False , raise_errors=True , extend_adj=True , clobber=True ) Deserialize and validate parameter adjustments. params_or_path can be a file path or a dict that has not been fully deserialized. The adjusted values replace the current values stored in the corresponding parameter attributes. If clobber is True and extend mode is on, then all future values for a given parameter be replaced by the values in the adjustment. If clobber is False and extend mode is on, then user-defined values will not be replaced by values in this adjustment. Only values that were added automatically via the extend method will be updated. This simply calls a private method _adjust to do the upate. Creating this layer on top of _adjust makes it easy to subclass Parameters and implement custom adjust methods. Parameters params_or_path : Adjustment that is either a dict , file path, or JSON string. ignore_warnings : Whether to raise an error on warnings or ignore them. raise_errors : Either raise errors or simply store the error messages. extend_adj : If in extend mode, this is a flag indicating whether to extend the adjustment values or not. clobber : If in extend mode, this is a flag indicating whether to override all values, including user-defined values, or to only override automatically created values. Returns params : Parsed, validated parameters. Raises marshmallow.exceptions.ValidationError if data is not valid. ParameterUpdateException if label values do not match at least one existing value item's corresponding label values. read_params ( self , params_or_path , storage_options=None ) Read JSON data of the form: Python dict . JSON string. Local file path. Any URL readable by fsspec. For example: s3: s3://paramtools-test/defaults.json gcs: gs://paramtools-dev/defaults.json http: https://somedomain.com/defaults.json github: github://PSLmodels:ParamTools@master/paramtools/tests/defaults.json Returns - params : Python Dict created from JSON file. set_state ( self , **labels ) Sets state for the Parameters instance. The _state , label_grid , and parameter attributes are all updated with the new state. Use the view_state method to inspect the current state of the instance, and use the clear_state method to revert to the default state. Raises ValidationError if the labels kwargs contain labels that are not specified in schema.json or if the label values fail the validator set for the corresponding label in schema.json. view_state ( self ) Access the label state of the Parameters instance. clear_state ( self ) Reset the state of the Parameters instance. specification ( self , use_state=True , meta_data=False , include_empty=False , serializable=False , sort_values=False , **labels ) Query value(s) of all parameters along labels specified in labels . Parameters use_state : Use the instance's state for the select operation. meta_data : Include information like the parameter description and title. include_empty : Include parameters that do not meet the label query. serializable : Return data that is compatible with json.dumps . sort_values : Sort values by the label order. Returns dict of parameter names and data. extend ( self , label=None , label_values=None , params=None , raise_errors=True , ignore_warnings=False ) Extend parameters along label . Parameters label : Label to extend values along. By default, label_to_extend is used. label_values : values of label to extend. By default, this is a grid created from the valid values of label_to_extend . params : Parameters to extend. By default, all parameters are extended. raise_errors : Whether adjust should raise or store errors. ignore_warnings : Whether adjust should raise or ignore warnings. Raises InconsistentLabelsException : Value objects do not have consistent labels. extend_func ( self , param , extend_vo , known_vo , extend_grid , label ) Function for applying indexing rates to parameter values as they are extended. Projects may implement their own extend_func by overriding this one. Projects need to write their own indexing_rate method for returning the correct indexing rate for a given parameter and value of label . Returns extend_vo : New ValueObject . to_array ( self , param , **labels ) Convert a Value object to an n-labelal array. The list of Value objects must span the specified parameter space. The parameter space is defined by inspecting the label validators in schema.json and the state attribute of the Parameters instance. Parameters - param : Name of parameter that will be used to create array. - labels : Optionally, override instance state. Returns arr : NumPy array created from list of value objects. Raises InconsistentLabelsException : Value objects do not have consistent labels. SparseValueObjectsException : Value object does not span the entire space specified by the Order object. ParamToolsError : Parameter is an array type and has labels. This is not supported by ParamTools when using array_first. from_array ( self , param , array=None , **labels ) Convert NumPy array to a Value object. Parameters param : Name of parameter to convert to a list of value objects. array : Optionally, provide a NumPy array to convert into a list of value objects. If not specified, the value at self.param will be used. labels : Optionally, override instance state. Returns List of ValueObjects Raises InconsistentLabelsException : Value objects do not have consistent labels. parse_labels ( self , **labels ) Parse and validate labels. Returns Parsed and validated labels. sort_values ( self , data=None , has_meta_data=True ) Sort value objects for all parameters in data according to the order specified in schema . Parameters data : Parameter data to be sorted. This should be a dict of parameter names and values. If data is None , the current values will be sorted. has_meta_data : Whether parameter values should be accessed directly or through the \"value\" attribute. Returns Sorted data.","title":"API documentation"}]}